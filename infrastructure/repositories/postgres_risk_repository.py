import logging
from sqlalchemy.orm import Session
from domain.entities.risk import Risk
from domain.repositories.risk_repository import IRiskRepository
from infrastructure.database.models import RiskDB # Importamos el modelo ORM

logger = logging.getLogger(__name__)

class PostgresRiskRepository(IRiskRepository):
    def __init__(self, db_session: Session):
        self.db_session = db_session

    async def save(self, risk: Risk) -> Risk:
        """
        Saves a new Risk entity to the PostgreSQL database.
        """
        try:
            # Convert domain entity to ORM model
            risk_db_model = RiskDB(
                id=risk.id,
                asset_id=risk.asset_id,
                vulnerability_id=risk.vulnerability_id,
                scan_id=risk.scan_id,
                ic_score=risk.ic_score,
                pc_score=risk.pc_score,
                nr_score=risk.nr_score
            )
            
            self.db_session.add(risk_db_model)
            await self.db_session.commit() # Asume un db_session as√≠ncrono o usa db_session.flush() y luego commit() del worker
            self.db_session.refresh(risk_db_model) # Para asegurar que cualquier campo autogenerado (ej. timestamps) se actualice

            logger.info(f"Successfully saved risk {risk_db_model.id} to DB.")
            
            # Convert ORM model back to domain entity (important if ID was generated by DB)
            return Risk.model_validate(risk_db_model)
        except Exception as e:
            logger.error(f"Error saving risk {risk.id}: {e}")
            await self.db_session.rollback() # Rollback in case of error
            raise # Re-raise to be handled by the consumer's error logic